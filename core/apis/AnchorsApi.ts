/* tslint:disable */
/* eslint-disable */
/**
 * Pieces Isomorphic OpenAPI
 * Endpoints for Assets, Formats, Users, Asset, Format, User.
 *
 * The version of the OpenAPI document: 1.0
 * Contact: tsavo@pieces.app
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import {
    Anchor,
    AnchorFromJSON,
    AnchorToJSON,
    Anchors,
    AnchorsFromJSON,
    AnchorsToJSON,
    SeededAnchor,
    SeededAnchorFromJSON,
    SeededAnchorToJSON,
} from '../models';

export interface AnchorsCreateNewAnchorRequest {
    transferables?: boolean;
    seededAnchor?: SeededAnchor;
}

export interface AnchorsDeleteSpecificAnchorRequest {
    anchor: string;
}

export interface AnchorsSnapshotRequest {
    transferables?: boolean;
}

export interface RemoveAnchorReferenceFromAssetRequest {
    anchor: string;
    asset: string;
}

/**
 * 
 */
export class AnchorsApi extends runtime.BaseAPI {

    /**
     * This will create a anchor and attach it to a specific asset(s) This will also ensure the anchor is normalized.
     * /anchors/create [POST]
     */
    async anchorsCreateNewAnchorRaw(requestParameters: AnchorsCreateNewAnchorRequest): Promise<runtime.ApiResponse<Anchor>> {
        const queryParameters: any = {};

        if (requestParameters.transferables !== undefined) {
            queryParameters['transferables'] = requestParameters.transferables;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/anchors/create`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: SeededAnchorToJSON(requestParameters.seededAnchor),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => AnchorFromJSON(jsonValue));
    }

    /**
     * This will create a anchor and attach it to a specific asset(s) This will also ensure the anchor is normalized.
     * /anchors/create [POST]
     */
    async anchorsCreateNewAnchor(requestParameters: AnchorsCreateNewAnchorRequest): Promise<Anchor> {
        const response = await this.anchorsCreateNewAnchorRaw(requestParameters);
        return await response.value();
    }

    /**
     * This will delete a specific anchor!
     * /anchors/{anchor}/delete [POST]
     */
    async anchorsDeleteSpecificAnchorRaw(requestParameters: AnchorsDeleteSpecificAnchorRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.anchor === null || requestParameters.anchor === undefined) {
            throw new runtime.RequiredError('anchor','Required parameter requestParameters.anchor was null or undefined when calling anchorsDeleteSpecificAnchor.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/anchors/{anchor}/delete`.replace(`{${"anchor"}}`, encodeURIComponent(String(requestParameters.anchor))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * This will delete a specific anchor!
     * /anchors/{anchor}/delete [POST]
     */
    async anchorsDeleteSpecificAnchor(requestParameters: AnchorsDeleteSpecificAnchorRequest): Promise<void> {
        await this.anchorsDeleteSpecificAnchorRaw(requestParameters);
    }

    /**
     * This will get a snapshot of all your anchors.
     * /anchors [GET]
     */
    async anchorsSnapshotRaw(requestParameters: AnchorsSnapshotRequest): Promise<runtime.ApiResponse<Anchors>> {
        const queryParameters: any = {};

        if (requestParameters.transferables !== undefined) {
            queryParameters['transferables'] = requestParameters.transferables;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/anchors`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => AnchorsFromJSON(jsonValue));
    }

    /**
     * This will get a snapshot of all your anchors.
     * /anchors [GET]
     */
    async anchorsSnapshot(requestParameters: AnchorsSnapshotRequest): Promise<Anchors> {
        const response = await this.anchorsSnapshotRaw(requestParameters);
        return await response.value();
    }

    /**
     * This will update both the asset and the anchor reference, that will remove a anchor from an asset(only the references).  This will NOT remove the anchor. This will NOT remove the asset. This will only update the references so that they are disconnected from one another.
     * /anchors/{anchor}/assets/delete/{asset} [POST]
     */
    async removeAnchorReferenceFromAssetRaw(requestParameters: RemoveAnchorReferenceFromAssetRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.anchor === null || requestParameters.anchor === undefined) {
            throw new runtime.RequiredError('anchor','Required parameter requestParameters.anchor was null or undefined when calling removeAnchorReferenceFromAsset.');
        }

        if (requestParameters.asset === null || requestParameters.asset === undefined) {
            throw new runtime.RequiredError('asset','Required parameter requestParameters.asset was null or undefined when calling removeAnchorReferenceFromAsset.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/anchors/{anchor}/assets/delete/{asset}`.replace(`{${"anchor"}}`, encodeURIComponent(String(requestParameters.anchor))).replace(`{${"asset"}}`, encodeURIComponent(String(requestParameters.asset))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * This will update both the asset and the anchor reference, that will remove a anchor from an asset(only the references).  This will NOT remove the anchor. This will NOT remove the asset. This will only update the references so that they are disconnected from one another.
     * /anchors/{anchor}/assets/delete/{asset} [POST]
     */
    async removeAnchorReferenceFromAsset(requestParameters: RemoveAnchorReferenceFromAssetRequest): Promise<void> {
        await this.removeAnchorReferenceFromAssetRaw(requestParameters);
    }

}
