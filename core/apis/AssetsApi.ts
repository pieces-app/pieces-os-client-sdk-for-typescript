/* tslint:disable */
/* eslint-disable */
/**
 * Pieces Isomorphic OpenAPI
 * Endpoints for Assets, Formats, Users, Asset, Format, User.
 *
 * The version of the OpenAPI document: 1.0
 * Contact: tsavo@pieces.app
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import {
    Asset,
    AssetFromJSON,
    AssetToJSON,
    Assets,
    AssetsFromJSON,
    AssetsToJSON,
    AssetsSearchWithFiltersInput,
    AssetsSearchWithFiltersInputFromJSON,
    AssetsSearchWithFiltersInputToJSON,
    AssetsSearchWithFiltersOutput,
    AssetsSearchWithFiltersOutputFromJSON,
    AssetsSearchWithFiltersOutputToJSON,
    FlattenedAssets,
    FlattenedAssetsFromJSON,
    FlattenedAssetsToJSON,
    Formats,
    FormatsFromJSON,
    FormatsToJSON,
    PseudoAssets,
    PseudoAssetsFromJSON,
    PseudoAssetsToJSON,
    SearchedAssets,
    SearchedAssetsFromJSON,
    SearchedAssetsToJSON,
    Seed,
    SeedFromJSON,
    SeedToJSON,
    SeededAssetsRecommendation,
    SeededAssetsRecommendationFromJSON,
    SeededAssetsRecommendationToJSON,
    StreamedIdentifiers,
    StreamedIdentifiersFromJSON,
    StreamedIdentifiersToJSON,
} from '../models';

export interface AssetsCreateNewAssetRequest {
    transferables?: boolean;
    seed?: Seed;
}

export interface AssetsDeleteAssetRequest {
    asset: string;
}

export interface AssetsDraftRequest {
    transferables?: boolean;
    seed?: Seed;
}

export interface AssetsGetRecommendedAssetsRequest {
    seededAssetsRecommendation?: SeededAssetsRecommendation;
}

export interface AssetsGetRelatedAssetsRequest {
    assets?: Assets;
}

export interface AssetsIdentifiersSnapshotRequest {
    pseudo?: boolean;
}

export interface AssetsSearchAssetsRequest {
    query?: string;
    transferables?: boolean;
    searchableTags?: string;
    pseudo?: boolean;
}

export interface AssetsSearchWithFiltersRequest {
    transferables?: boolean;
    pseudo?: boolean;
    assetsSearchWithFiltersInput?: AssetsSearchWithFiltersInput;
}

export interface AssetsSnapshotRequest {
    transferables?: boolean;
    suggested?: boolean;
    pseudo?: boolean;
}

export interface AssetsSpecificAssetFormatsSnapshotRequest {
    asset: string;
    transferables?: boolean;
}

export interface AssetsSpecificAssetSnapshotRequest {
    asset: string;
    transferables?: boolean;
}

/**
 * 
 */
export class AssetsApi extends runtime.BaseAPI {

    /**
     * This endpoint will accept a seeded (a structure that comes before an asset, will be used in creation) asset to be uploaded to pieces. Response here will be an Asset that was create!
     * /assets/create [POST] Scoped to Asset
     */
    async assetsCreateNewAssetRaw(requestParameters: AssetsCreateNewAssetRequest): Promise<runtime.ApiResponse<Asset>> {
        const queryParameters: any = {};

        if (requestParameters.transferables !== undefined) {
            queryParameters['transferables'] = requestParameters.transferables;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/assets/create`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: SeedToJSON(requestParameters.seed),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => AssetFromJSON(jsonValue));
    }

    /**
     * This endpoint will accept a seeded (a structure that comes before an asset, will be used in creation) asset to be uploaded to pieces. Response here will be an Asset that was create!
     * /assets/create [POST] Scoped to Asset
     */
    async assetsCreateNewAsset(requestParameters: AssetsCreateNewAssetRequest): Promise<Asset> {
        const response = await this.assetsCreateNewAssetRaw(requestParameters);
        return await response.value();
    }

    /**
     * This endpoint will just take a uid to delete out of the assets table, will return the uid that was deleted.
     * /assets/delete [POST] Scoped to Asset
     */
    async assetsDeleteAssetRaw(requestParameters: AssetsDeleteAssetRequest): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.asset === null || requestParameters.asset === undefined) {
            throw new runtime.RequiredError('asset','Required parameter requestParameters.asset was null or undefined when calling assetsDeleteAsset.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/assets/{asset}/delete`.replace(`{${"asset"}}`, encodeURIComponent(String(requestParameters.asset))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * This endpoint will just take a uid to delete out of the assets table, will return the uid that was deleted.
     * /assets/delete [POST] Scoped to Asset
     */
    async assetsDeleteAsset(requestParameters: AssetsDeleteAssetRequest): Promise<string> {
        const response = await this.assetsDeleteAssetRaw(requestParameters);
        return await response.value();
    }

    /**
     * This is an endpoint that will enable a developer to pass in a Seed and get a seed with preprocessed information on that seed out of this endpoint, nothing is persisted, this is a strict input/output endpoint. and return a drafted asset (seed with some initial information).  for images, we will just return the seed that was passed to us. a TODO for v2 would eb to add preprocessing for images as well.
     * /assets/draft [POST]
     */
    async assetsDraftRaw(requestParameters: AssetsDraftRequest): Promise<runtime.ApiResponse<Seed>> {
        const queryParameters: any = {};

        if (requestParameters.transferables !== undefined) {
            queryParameters['transferables'] = requestParameters.transferables;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/assets/draft`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: SeedToJSON(requestParameters.seed),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => SeedFromJSON(jsonValue));
    }

    /**
     * This is an endpoint that will enable a developer to pass in a Seed and get a seed with preprocessed information on that seed out of this endpoint, nothing is persisted, this is a strict input/output endpoint. and return a drafted asset (seed with some initial information).  for images, we will just return the seed that was passed to us. a TODO for v2 would eb to add preprocessing for images as well.
     * /assets/draft [POST]
     */
    async assetsDraft(requestParameters: AssetsDraftRequest): Promise<Seed> {
        const response = await this.assetsDraftRaw(requestParameters);
        return await response.value();
    }

    /**
     * An endpoint that takes in a SeededAssetsRecommendation Model within it\'s request body, which requires an object including assets (Assets Model) as well as interactions (InteractedAssets Model) - the resulting will return an Assets Model for use in a UI.
     * Your GET endpoint
     */
    async assetsGetRecommendedAssetsRaw(requestParameters: AssetsGetRecommendedAssetsRequest): Promise<runtime.ApiResponse<Assets>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/assets/recommended`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
            body: SeededAssetsRecommendationToJSON(requestParameters.seededAssetsRecommendation),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => AssetsFromJSON(jsonValue));
    }

    /**
     * An endpoint that takes in a SeededAssetsRecommendation Model within it\'s request body, which requires an object including assets (Assets Model) as well as interactions (InteractedAssets Model) - the resulting will return an Assets Model for use in a UI.
     * Your GET endpoint
     */
    async assetsGetRecommendedAssets(requestParameters: AssetsGetRecommendedAssetsRequest): Promise<Assets> {
        const response = await this.assetsGetRecommendedAssetsRaw(requestParameters);
        return await response.value();
    }

    /**
     * Gets one or more related assets when provided one or more input assets. The body will expect the shape of
     * /assets/related [GET]
     */
    async assetsGetRelatedAssetsRaw(requestParameters: AssetsGetRelatedAssetsRequest): Promise<runtime.ApiResponse<Assets>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/assets/related`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
            body: AssetsToJSON(requestParameters.assets),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => AssetsFromJSON(jsonValue));
    }

    /**
     * Gets one or more related assets when provided one or more input assets. The body will expect the shape of
     * /assets/related [GET]
     */
    async assetsGetRelatedAssets(requestParameters: AssetsGetRelatedAssetsRequest): Promise<Assets> {
        const response = await this.assetsGetRelatedAssetsRaw(requestParameters);
        return await response.value();
    }

    /**
     * This will get all of your asset ids
     * /assets/identifiers [GET]
     */
    async assetsIdentifiersSnapshotRaw(requestParameters: AssetsIdentifiersSnapshotRequest): Promise<runtime.ApiResponse<FlattenedAssets>> {
        const queryParameters: any = {};

        if (requestParameters.pseudo !== undefined) {
            queryParameters['pseudo'] = requestParameters.pseudo;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/assets/identifiers`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => FlattenedAssetsFromJSON(jsonValue));
    }

    /**
     * This will get all of your asset ids
     * /assets/identifiers [GET]
     */
    async assetsIdentifiersSnapshot(requestParameters: AssetsIdentifiersSnapshotRequest): Promise<FlattenedAssets> {
        const response = await this.assetsIdentifiersSnapshotRaw(requestParameters);
        return await response.value();
    }

    /**
     * This will get a snapshot of ONLY the pseudo Assets included in your Pieces drive.
     * /assets/pseudo [GET]
     */
    async assetsPseudoSnapshotRaw(): Promise<runtime.ApiResponse<PseudoAssets>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/assets/pseudo`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => PseudoAssetsFromJSON(jsonValue));
    }

    /**
     * This will get a snapshot of ONLY the pseudo Assets included in your Pieces drive.
     * /assets/pseudo [GET]
     */
    async assetsPseudoSnapshot(): Promise<PseudoAssets> {
        const response = await this.assetsPseudoSnapshotRaw();
        return await response.value();
    }

    /**
     * This function will search your pieces and will return Assets(the results) based on your query! Eventually** /assets/search?query=string [GET] Scoped to Asset  Currently just send along your query in the body.  Required to pass searchable_tags (csv of tags) or a query string.  if a query is passed we will run through fuzzy search.  if searchable_tags are passed we will run through tag_based_search.  if neither are passed in we will return a 500.
     * /assets/search?query=string [GET]
     */
    async assetsSearchAssetsRaw(requestParameters: AssetsSearchAssetsRequest): Promise<runtime.ApiResponse<SearchedAssets>> {
        const queryParameters: any = {};

        if (requestParameters.query !== undefined) {
            queryParameters['query'] = requestParameters.query;
        }

        if (requestParameters.transferables !== undefined) {
            queryParameters['transferables'] = requestParameters.transferables;
        }

        if (requestParameters.searchableTags !== undefined) {
            queryParameters['searchable_tags'] = requestParameters.searchableTags;
        }

        if (requestParameters.pseudo !== undefined) {
            queryParameters['pseudo'] = requestParameters.pseudo;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/assets/search`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => SearchedAssetsFromJSON(jsonValue));
    }

    /**
     * This function will search your pieces and will return Assets(the results) based on your query! Eventually** /assets/search?query=string [GET] Scoped to Asset  Currently just send along your query in the body.  Required to pass searchable_tags (csv of tags) or a query string.  if a query is passed we will run through fuzzy search.  if searchable_tags are passed we will run through tag_based_search.  if neither are passed in we will return a 500.
     * /assets/search?query=string [GET]
     */
    async assetsSearchAssets(requestParameters: AssetsSearchAssetsRequest): Promise<SearchedAssets> {
        const response = await this.assetsSearchAssetsRaw(requestParameters);
        return await response.value();
    }

    /**
     * This function will search your pieces and will return Assets(the results) based on your query! /assets/search [POST] Scoped to Asset  Currently just send along your query in the body.  if a query is passed we will run through fuzzy search.  The Post Body will also accept a search space, being either a list of uuids.(in the future potentially Seeds.) The Post Body will also accept optional filters, which is an iterable of filters all will be AND operations for now.
     * /assets/search [POST]
     */
    async assetsSearchWithFiltersRaw(requestParameters: AssetsSearchWithFiltersRequest): Promise<runtime.ApiResponse<AssetsSearchWithFiltersOutput>> {
        const queryParameters: any = {};

        if (requestParameters.transferables !== undefined) {
            queryParameters['transferables'] = requestParameters.transferables;
        }

        if (requestParameters.pseudo !== undefined) {
            queryParameters['pseudo'] = requestParameters.pseudo;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/assets/search`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: AssetsSearchWithFiltersInputToJSON(requestParameters.assetsSearchWithFiltersInput),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => AssetsSearchWithFiltersOutputFromJSON(jsonValue));
    }

    /**
     * This function will search your pieces and will return Assets(the results) based on your query! /assets/search [POST] Scoped to Asset  Currently just send along your query in the body.  if a query is passed we will run through fuzzy search.  The Post Body will also accept a search space, being either a list of uuids.(in the future potentially Seeds.) The Post Body will also accept optional filters, which is an iterable of filters all will be AND operations for now.
     * /assets/search [POST]
     */
    async assetsSearchWithFilters(requestParameters: AssetsSearchWithFiltersRequest): Promise<AssetsSearchWithFiltersOutput> {
        const response = await this.assetsSearchWithFiltersRaw(requestParameters);
        return await response.value();
    }

    /**
     * Get all of the users Assets.
     * /assets [GET] Scoped to Assets
     */
    async assetsSnapshotRaw(requestParameters: AssetsSnapshotRequest): Promise<runtime.ApiResponse<Assets>> {
        const queryParameters: any = {};

        if (requestParameters.transferables !== undefined) {
            queryParameters['transferables'] = requestParameters.transferables;
        }

        if (requestParameters.suggested !== undefined) {
            queryParameters['suggested'] = requestParameters.suggested;
        }

        if (requestParameters.pseudo !== undefined) {
            queryParameters['pseudo'] = requestParameters.pseudo;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/assets`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => AssetsFromJSON(jsonValue));
    }

    /**
     * Get all of the users Assets.
     * /assets [GET] Scoped to Assets
     */
    async assetsSnapshot(requestParameters: AssetsSnapshotRequest): Promise<Assets> {
        const response = await this.assetsSnapshotRaw(requestParameters);
        return await response.value();
    }

    /**
     * This will query the formats for agiven asset when provided that asset\'s id.
     * /assets/{asset}/formats [GET] Scoped To Assets
     */
    async assetsSpecificAssetFormatsSnapshotRaw(requestParameters: AssetsSpecificAssetFormatsSnapshotRequest): Promise<runtime.ApiResponse<Formats>> {
        if (requestParameters.asset === null || requestParameters.asset === undefined) {
            throw new runtime.RequiredError('asset','Required parameter requestParameters.asset was null or undefined when calling assetsSpecificAssetFormatsSnapshot.');
        }

        const queryParameters: any = {};

        if (requestParameters.transferables !== undefined) {
            queryParameters['transferables'] = requestParameters.transferables;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/assets/{asset}/formats`.replace(`{${"asset"}}`, encodeURIComponent(String(requestParameters.asset))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => FormatsFromJSON(jsonValue));
    }

    /**
     * This will query the formats for a given asset when provided that asset\'s id.
     * /assets/{asset}/formats [GET] Scoped To Assets
     */
    async assetsSpecificAssetFormatsSnapshot(requestParameters: AssetsSpecificAssetFormatsSnapshotRequest): Promise<Formats> {
        const response = await this.assetsSpecificAssetFormatsSnapshotRaw(requestParameters);
        return await response.value();
    }

    /**
     * This is an endpoint to enable a client to access a specific asset through a provided uuid in the path.
     * /assets/{asset} [GET] Scoped to Assets
     */
    async assetsSpecificAssetSnapshotRaw(requestParameters: AssetsSpecificAssetSnapshotRequest): Promise<runtime.ApiResponse<Asset>> {
        if (requestParameters.asset === null || requestParameters.asset === undefined) {
            throw new runtime.RequiredError('asset','Required parameter requestParameters.asset was null or undefined when calling assetsSpecificAssetSnapshot.');
        }

        const queryParameters: any = {};

        if (requestParameters.transferables !== undefined) {
            queryParameters['transferables'] = requestParameters.transferables;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/assets/{asset}`.replace(`{${"asset"}}`, encodeURIComponent(String(requestParameters.asset))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => AssetFromJSON(jsonValue));
    }

    /**
     * This is an endpoint to enable a client to access a specific asset through a provided uuid in the path.
     * /assets/{asset} [GET] Scoped to Assets
     */
    async assetsSpecificAssetSnapshot(requestParameters: AssetsSpecificAssetSnapshotRequest): Promise<Asset> {
        const response = await this.assetsSpecificAssetSnapshotRaw(requestParameters);
        return await response.value();
    }

    /**
     * This will stream the asset identifiers(uuids) that have changed via a websocket connection.
     * /assets/stream/identifiers [GET]
     */
    async assetsStreamIdentifiersRaw(): Promise<runtime.ApiResponse<StreamedIdentifiers>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/assets/stream/identifiers`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => StreamedIdentifiersFromJSON(jsonValue));
    }

    /**
     * This will stream the asset identifiers(uuids) that have changed via a websocket connection.
     * /assets/stream/identifiers [GET]
     */
    async assetsStreamIdentifiers(): Promise<StreamedIdentifiers> {
        const response = await this.assetsStreamIdentifiersRaw();
        return await response.value();
    }

    /**
     * This will emit changes of your assets with your transferables included. This is a websocket connection.
     * Your GET endpoint
     */
    async getAssetsStreamTransferablesRaw(): Promise<runtime.ApiResponse<Assets>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/assets/stream/transferables`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => AssetsFromJSON(jsonValue));
    }

    /**
     * This will emit changes of your assets with your transferables included. This is a websocket connection.
     * Your GET endpoint
     */
    async getAssetsStreamTransferables(): Promise<Assets> {
        const response = await this.getAssetsStreamTransferablesRaw();
        return await response.value();
    }

    /**
     * *** IMPORTANT this stream will emit changes WITHOUT the transferables on a format. if you want transferables included please refer to /assets/stream/transferables
     * /assets/stream [GET]
     */
    async streamAssetsRaw(): Promise<runtime.ApiResponse<Assets>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/assets/stream`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => AssetsFromJSON(jsonValue));
    }

    /**
     * *** IMPORTANT this stream will emit changes WITHOUT the transferables on a format. if you want transferables included please refer to /assets/stream/transferables
     * /assets/stream [GET]
     */
    async streamAssets(): Promise<Assets> {
        const response = await this.streamAssetsRaw();
        return await response.value();
    }

}
