/* tslint:disable */
/* eslint-disable */
/**
 * Pieces Isomorphic OpenAPI
 * Endpoints for Assets, Formats, Users, Asset, Format, User.
 *
 * The version of the OpenAPI document: 1.0
 * Contact: tsavo@pieces.app
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  FoundryDeployment,
  FoundryDeployments,
  FoundryStatus,
} from '../models/index';
import {
    FoundryDeploymentFromJSON,
    FoundryDeploymentToJSON,
    FoundryDeploymentsFromJSON,
    FoundryDeploymentsToJSON,
    FoundryStatusFromJSON,
    FoundryStatusToJSON,
} from '../models/index';

export interface FoundryInstallCancelRequest {
    identifier: string;
}

export interface FoundryInstallSnapshotRequest {
    identifier: string;
}

export interface FoundryUninstallRequest {
    foundryDeployment?: FoundryDeployment;
}

export interface FoundryUpdateRequest {
    foundryDeployment?: FoundryDeployment;
}

export interface FoundryUpdateCancelRequest {
    identifier: string;
}

export interface FoundryUpdateSnapshotRequest {
    identifier: string;
}

/**
 * 
 */
export class FoundryApi extends runtime.BaseAPI {

    /**
     * This will start the installation for foundry. NOTE: This will return immediately, use the update status
     * /foundry/install [POST]
     */
    async foundryInstallRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FoundryDeployment>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Application-ID"] = await this.configuration.apiKey("X-Application-ID"); // application authentication
        }

        const response = await this.request({
            path: `/foundry/install`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FoundryDeploymentFromJSON(jsonValue));
    }

    /**
     * This will start the installation for foundry. NOTE: This will return immediately, use the update status
     * /foundry/install [POST]
     */
    async foundryInstall(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FoundryDeployment> {
        const response = await this.foundryInstallRaw(initOverrides);
        return await response.value();
    }

    /**
     * This will cancel a specific installation that is in-progress.
     * /foundry/install/{identifier}/cancel [POST]
     */
    async foundryInstallCancelRaw(requestParameters: FoundryInstallCancelRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FoundryDeployment>> {
        if (requestParameters['identifier'] == null) {
            throw new runtime.RequiredError(
                'identifier',
                'Required parameter "identifier" was null or undefined when calling foundryInstallCancel().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Application-ID"] = await this.configuration.apiKey("X-Application-ID"); // application authentication
        }

        const response = await this.request({
            path: `/foundry/install/{identifier}/cancel`.replace(`{${"identifier"}}`, encodeURIComponent(String(requestParameters['identifier']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FoundryDeploymentFromJSON(jsonValue));
    }

    /**
     * This will cancel a specific installation that is in-progress.
     * /foundry/install/{identifier}/cancel [POST]
     */
    async foundryInstallCancel(requestParameters: FoundryInstallCancelRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FoundryDeployment> {
        const response = await this.foundryInstallCancelRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * This will get the status of a given installation
     * /foundry/install/{identifier} [GET]
     */
    async foundryInstallSnapshotRaw(requestParameters: FoundryInstallSnapshotRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FoundryDeployment>> {
        if (requestParameters['identifier'] == null) {
            throw new runtime.RequiredError(
                'identifier',
                'Required parameter "identifier" was null or undefined when calling foundryInstallSnapshot().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Application-ID"] = await this.configuration.apiKey("X-Application-ID"); // application authentication
        }

        const response = await this.request({
            path: `/foundry/install/{identifier}`.replace(`{${"identifier"}}`, encodeURIComponent(String(requestParameters['identifier']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FoundryDeploymentFromJSON(jsonValue));
    }

    /**
     * This will get the status of a given installation
     * /foundry/install/{identifier} [GET]
     */
    async foundryInstallSnapshot(requestParameters: FoundryInstallSnapshotRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FoundryDeployment> {
        const response = await this.foundryInstallSnapshotRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * This will return all the installation in a given session
     * /foundry/installs [GET]
     */
    async foundryInstallsSnapshotRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FoundryDeployments>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Application-ID"] = await this.configuration.apiKey("X-Application-ID"); // application authentication
        }

        const response = await this.request({
            path: `/foundry/installs`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FoundryDeploymentsFromJSON(jsonValue));
    }

    /**
     * This will return all the installation in a given session
     * /foundry/installs [GET]
     */
    async foundryInstallsSnapshot(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FoundryDeployments> {
        const response = await this.foundryInstallsSnapshotRaw(initOverrides);
        return await response.value();
    }

    /**
     * This will get a status on foundry, ie if ollama is installed, if it needs an update,  if there are installations in progress, or updates in progress
     * /foundry/status [GET]
     */
    async foundryStatusCheckRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FoundryStatus>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Application-ID"] = await this.configuration.apiKey("X-Application-ID"); // application authentication
        }

        const response = await this.request({
            path: `/foundry/status`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FoundryStatusFromJSON(jsonValue));
    }

    /**
     * This will get a status on foundry, ie if ollama is installed, if it needs an update,  if there are installations in progress, or updates in progress
     * /foundry/status [GET]
     */
    async foundryStatusCheck(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FoundryStatus> {
        const response = await this.foundryStatusCheckRaw(initOverrides);
        return await response.value();
    }

    /**
     * This provides a Websocket connection, that will emit a change on the initial connection and then all realtime updates: - if an update have started - if an installation has started - if foundry has been installed/uninstalled - if an updated is required for Ollama
     * /foundry/status/stream [WS]
     */
    async foundryStatusCheckStreamRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FoundryStatus>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Application-ID"] = await this.configuration.apiKey("X-Application-ID"); // application authentication
        }

        const response = await this.request({
            path: `/foundry/status/stream`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FoundryStatusFromJSON(jsonValue));
    }

    /**
     * This provides a Websocket connection, that will emit a change on the initial connection and then all realtime updates: - if an update have started - if an installation has started - if foundry has been installed/uninstalled - if an updated is required for Ollama
     * /foundry/status/stream [WS]
     */
    async foundryStatusCheckStream(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FoundryStatus> {
        const response = await this.foundryStatusCheckStreamRaw(initOverrides);
        return await response.value();
    }

    /**
     * This will uninstall foundry.  NOTE: the request body is the installation that will be deleted.
     * /foundry/uninstall [POST]
     */
    async foundryUninstallRaw(requestParameters: FoundryUninstallRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FoundryDeployment>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Application-ID"] = await this.configuration.apiKey("X-Application-ID"); // application authentication
        }

        const response = await this.request({
            path: `/foundry/uninstall`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: FoundryDeploymentToJSON(requestParameters['foundryDeployment']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FoundryDeploymentFromJSON(jsonValue));
    }

    /**
     * This will uninstall foundry.  NOTE: the request body is the installation that will be deleted.
     * /foundry/uninstall [POST]
     */
    async foundryUninstall(requestParameters: FoundryUninstallRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FoundryDeployment> {
        const response = await this.foundryUninstallRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * This will start the update for Foundry. NOTE: This will return immediately, use the Foundry status endpoint to checks it status. NOTE: This will required a user to pass in deployment that they would like to update to.(only thing required will be version here, and that this is a valid version to update to.)
     * /foundry/update [POST]
     */
    async foundryUpdateRaw(requestParameters: FoundryUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FoundryDeployment>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Application-ID"] = await this.configuration.apiKey("X-Application-ID"); // application authentication
        }

        const response = await this.request({
            path: `/foundry/update`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: FoundryDeploymentToJSON(requestParameters['foundryDeployment']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FoundryDeploymentFromJSON(jsonValue));
    }

    /**
     * This will start the update for Foundry. NOTE: This will return immediately, use the Foundry status endpoint to checks it status. NOTE: This will required a user to pass in deployment that they would like to update to.(only thing required will be version here, and that this is a valid version to update to.)
     * /foundry/update [POST]
     */
    async foundryUpdate(requestParameters: FoundryUpdateRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FoundryDeployment> {
        const response = await this.foundryUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * This will cancel a specific update that is in-progress.
     * /foundry/update/{identifier}/cancel [POST]
     */
    async foundryUpdateCancelRaw(requestParameters: FoundryUpdateCancelRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FoundryDeployment>> {
        if (requestParameters['identifier'] == null) {
            throw new runtime.RequiredError(
                'identifier',
                'Required parameter "identifier" was null or undefined when calling foundryUpdateCancel().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Application-ID"] = await this.configuration.apiKey("X-Application-ID"); // application authentication
        }

        const response = await this.request({
            path: `/foundry/update/{identifier}/cancel`.replace(`{${"identifier"}}`, encodeURIComponent(String(requestParameters['identifier']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FoundryDeploymentFromJSON(jsonValue));
    }

    /**
     * This will cancel a specific update that is in-progress.
     * /foundry/update/{identifier}/cancel [POST]
     */
    async foundryUpdateCancel(requestParameters: FoundryUpdateCancelRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FoundryDeployment> {
        const response = await this.foundryUpdateCancelRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * This will get the status of a given update.
     * /foundry/update/{identifier} [GET]
     */
    async foundryUpdateSnapshotRaw(requestParameters: FoundryUpdateSnapshotRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FoundryDeployment>> {
        if (requestParameters['identifier'] == null) {
            throw new runtime.RequiredError(
                'identifier',
                'Required parameter "identifier" was null or undefined when calling foundryUpdateSnapshot().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Application-ID"] = await this.configuration.apiKey("X-Application-ID"); // application authentication
        }

        const response = await this.request({
            path: `/foundry/update/{identifier}`.replace(`{${"identifier"}}`, encodeURIComponent(String(requestParameters['identifier']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FoundryDeploymentFromJSON(jsonValue));
    }

    /**
     * This will get the status of a given update.
     * /foundry/update/{identifier} [GET]
     */
    async foundryUpdateSnapshot(requestParameters: FoundryUpdateSnapshotRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FoundryDeployment> {
        const response = await this.foundryUpdateSnapshotRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * This will return all the attempted updates in a given session
     * /foundry/updates [GET]
     */
    async foundryUpdatesSnapshotRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FoundryDeployments>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Application-ID"] = await this.configuration.apiKey("X-Application-ID"); // application authentication
        }

        const response = await this.request({
            path: `/foundry/updates`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FoundryDeploymentsFromJSON(jsonValue));
    }

    /**
     * This will return all the attempted updates in a given session
     * /foundry/updates [GET]
     */
    async foundryUpdatesSnapshot(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FoundryDeployments> {
        const response = await this.foundryUpdatesSnapshotRaw(initOverrides);
        return await response.value();
    }

}
