/* tslint:disable */
/* eslint-disable */
/**
 * Pieces Isomorphic OpenAPI
 * Endpoints for Assets, Formats, Users, Asset, Format, User.
 *
 * The version of the OpenAPI document: 1.0
 * Contact: tsavo@pieces.app
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  ActiveOSServerApplet,
  FilePickerInput,
  InactiveOSServerApplet,
  NanoModelsPreparationInput,
  OSDeviceInformationReturnable,
  OSFileStreamingRead,
  OSFileStreamingReadAttempt,
  OSPermissions,
  OSServerMetadata,
  OSServerSettings,
  OSServerUpdateStatus,
  ReturnedUserProfile,
  SeededExternalProvider,
  TerminatingOSServerApplet,
  UncheckedOSServerUpdate,
  UserProfile,
  Users,
  VerifiedOSFilesystemPath,
} from '../models/index';
import {
    ActiveOSServerAppletFromJSON,
    ActiveOSServerAppletToJSON,
    FilePickerInputFromJSON,
    FilePickerInputToJSON,
    InactiveOSServerAppletFromJSON,
    InactiveOSServerAppletToJSON,
    NanoModelsPreparationInputFromJSON,
    NanoModelsPreparationInputToJSON,
    OSDeviceInformationReturnableFromJSON,
    OSDeviceInformationReturnableToJSON,
    OSFileStreamingReadFromJSON,
    OSFileStreamingReadToJSON,
    OSFileStreamingReadAttemptFromJSON,
    OSFileStreamingReadAttemptToJSON,
    OSPermissionsFromJSON,
    OSPermissionsToJSON,
    OSServerMetadataFromJSON,
    OSServerMetadataToJSON,
    OSServerSettingsFromJSON,
    OSServerSettingsToJSON,
    OSServerUpdateStatusFromJSON,
    OSServerUpdateStatusToJSON,
    ReturnedUserProfileFromJSON,
    ReturnedUserProfileToJSON,
    SeededExternalProviderFromJSON,
    SeededExternalProviderToJSON,
    TerminatingOSServerAppletFromJSON,
    TerminatingOSServerAppletToJSON,
    UncheckedOSServerUpdateFromJSON,
    UncheckedOSServerUpdateToJSON,
    UserProfileFromJSON,
    UserProfileToJSON,
    UsersFromJSON,
    UsersToJSON,
    VerifiedOSFilesystemPathFromJSON,
    VerifiedOSFilesystemPathToJSON,
} from '../models/index';

export interface LinkProviderRequest {
    seededExternalProvider?: SeededExternalProvider;
}

export interface OsAppletLaunchRequest {
    inactiveOSServerApplet?: InactiveOSServerApplet;
}

export interface OsAppletRestartRequest {
    inactiveOSServerApplet?: InactiveOSServerApplet;
}

export interface OsAppletTerminateRequest {
    terminatingOSServerApplet?: TerminatingOSServerApplet;
}

export interface OsBrowserUrlOpenRequest {
    body?: string;
}

export interface OsFilesystemFileOpenRequest {
    body?: string;
}

export interface OsFilesystemFileReadStreamedRequest {
    oSFileStreamingReadAttempt?: OSFileStreamingReadAttempt;
}

export interface OsFilesystemPathVerifyRequest {
    body?: string;
}

export interface OsFilesystemPickFilesRequest {
    filePickerInput?: FilePickerInput;
}

export interface OsNanoModelsPrepareRequest {
    nanoModelsPreparationInput?: NanoModelsPreparationInput;
}

export interface OsPermissionsRequestRequest {
    oSPermissions?: OSPermissions;
}

export interface OsSettingsUpdateRequest {
    oSServerSettings?: OSServerSettings;
}

export interface OsUpdateCheckRequest {
    uncheckedOSServerUpdate?: UncheckedOSServerUpdate;
}

/**
 * 
 */
export class OSApi extends runtime.BaseAPI {

    /**
     * This will link an external provider to your current auth0 account.  Will throw errors if your user is not signed in.
     * /os/link_provider [POST]
     */
    async linkProviderRaw(requestParameters: LinkProviderRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ReturnedUserProfile>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Application-ID"] = await this.configuration.apiKey("X-Application-ID"); // application authentication
        }

        const response = await this.request({
            path: `/os/link_provider`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: SeededExternalProviderToJSON(requestParameters['seededExternalProvider']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ReturnedUserProfileFromJSON(jsonValue));
    }

    /**
     * This will link an external provider to your current auth0 account.  Will throw errors if your user is not signed in.
     * /os/link_provider [POST]
     */
    async linkProvider(requestParameters: LinkProviderRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ReturnedUserProfile> {
        const response = await this.linkProviderRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * This will attempt to launch(serve) a micro_application. If one is already spun up we will just return the port number. TODO: take in an application and return a port number at minimum.
     * /os/applet/launch [POST]
     */
    async osAppletLaunchRaw(requestParameters: OsAppletLaunchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ActiveOSServerApplet>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Application-ID"] = await this.configuration.apiKey("X-Application-ID"); // application authentication
        }

        const response = await this.request({
            path: `/os/applet/launch`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: InactiveOSServerAppletToJSON(requestParameters['inactiveOSServerApplet']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ActiveOSServerAppletFromJSON(jsonValue));
    }

    /**
     * This will attempt to launch(serve) a micro_application. If one is already spun up we will just return the port number. TODO: take in an application and return a port number at minimum.
     * /os/applet/launch [POST]
     */
    async osAppletLaunch(requestParameters: OsAppletLaunchRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ActiveOSServerApplet> {
        const response = await this.osAppletLaunchRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * This will attempt to restart a micro_application.(this will shut down the copilot and then rehost it)
     * /os/applet/restart [POST]
     */
    async osAppletRestartRaw(requestParameters: OsAppletRestartRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ActiveOSServerApplet>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Application-ID"] = await this.configuration.apiKey("X-Application-ID"); // application authentication
        }

        const response = await this.request({
            path: `/os/applet/restart`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: InactiveOSServerAppletToJSON(requestParameters['inactiveOSServerApplet']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ActiveOSServerAppletFromJSON(jsonValue));
    }

    /**
     * This will attempt to restart a micro_application.(this will shut down the copilot and then rehost it)
     * /os/applet/restart [POST]
     */
    async osAppletRestart(requestParameters: OsAppletRestartRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ActiveOSServerApplet> {
        const response = await this.osAppletRestartRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * This will attempt to shutdown or terminate a specified micro_application.
     * /os/applet/terminate [POST]
     */
    async osAppletTerminateRaw(requestParameters: OsAppletTerminateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Application-ID"] = await this.configuration.apiKey("X-Application-ID"); // application authentication
        }

        const response = await this.request({
            path: `/os/applet/terminate`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: TerminatingOSServerAppletToJSON(requestParameters['terminatingOSServerApplet']),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * This will attempt to shutdown or terminate a specified micro_application.
     * /os/applet/terminate [POST]
     */
    async osAppletTerminate(requestParameters: OsAppletTerminateRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.osAppletTerminateRaw(requestParameters, initOverrides);
    }

    /**
     * This will accept a url and launch this in an external browser.
     * /os/browser/url/open [POST]
     */
    async osBrowserUrlOpenRaw(requestParameters: OsBrowserUrlOpenRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Application-ID"] = await this.configuration.apiKey("X-Application-ID"); // application authentication
        }

        const response = await this.request({
            path: `/os/browser/url/open`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['body'] as any,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * This will accept a url and launch this in an external browser.
     * /os/browser/url/open [POST]
     */
    async osBrowserUrlOpen(requestParameters: OsBrowserUrlOpenRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.osBrowserUrlOpenRaw(requestParameters, initOverrides);
    }

    /**
     * This will get information related to your specific device.
     * /os/device/information [GET]
     */
    async osDeviceInformationRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<OSDeviceInformationReturnable>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Application-ID"] = await this.configuration.apiKey("X-Application-ID"); // application authentication
        }

        const response = await this.request({
            path: `/os/device/information`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => OSDeviceInformationReturnableFromJSON(jsonValue));
    }

    /**
     * This will get information related to your specific device.
     * /os/device/information [GET]
     */
    async osDeviceInformation(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<OSDeviceInformationReturnable> {
        const response = await this.osDeviceInformationRaw(initOverrides);
        return await response.value();
    }

    /**
     * This will accept a path and will launch a path in a given finder/file explorer window  note: TODO in the future add an endpoint for open/in || open/with (browser,files,...etc)       && if so we will want /os/open_with/file
     * /os/filesystem/file/open [POST]
     */
    async osFilesystemFileOpenRaw(requestParameters: OsFilesystemFileOpenRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Application-ID"] = await this.configuration.apiKey("X-Application-ID"); // application authentication
        }

        const response = await this.request({
            path: `/os/filesystem/file/open`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['body'] as any,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * This will accept a path and will launch a path in a given finder/file explorer window  note: TODO in the future add an endpoint for open/in || open/with (browser,files,...etc)       && if so we will want /os/open_with/file
     * /os/filesystem/file/open [POST]
     */
    async osFilesystemFileOpen(requestParameters: OsFilesystemFileOpenRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.osFilesystemFileOpenRaw(requestParameters, initOverrides);
    }

    /**
     * This will stream(via a WS the contents of a file back to the client, given a file, it will read the contents and return to the client.  NOTE: will NOT support relative paths. only ABSOLUTE paths. NOTE: needs to be a File.(will not stream a folder) NOTE: we might want to put a limit on the size of the file(IE no more than a GB or something like that??) TODO: would be nice to cancel stream NOTE: for v2 we could have two query params i.e. find which could take in a relative path and or file name and        the other could be compress i.e. streaming a gzip vs the raw bytes..        the caveat here would be mack would need to decompress em.
     * /os/filesystem/file/read/streamed [WS]
     */
    async osFilesystemFileReadStreamedRaw(requestParameters: OsFilesystemFileReadStreamedRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<OSFileStreamingRead>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Application-ID"] = await this.configuration.apiKey("X-Application-ID"); // application authentication
        }

        const response = await this.request({
            path: `/os/filesystem/file/read/streamed`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
            body: OSFileStreamingReadAttemptToJSON(requestParameters['oSFileStreamingReadAttempt']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => OSFileStreamingReadFromJSON(jsonValue));
    }

    /**
     * This will stream(via a WS the contents of a file back to the client, given a file, it will read the contents and return to the client.  NOTE: will NOT support relative paths. only ABSOLUTE paths. NOTE: needs to be a File.(will not stream a folder) NOTE: we might want to put a limit on the size of the file(IE no more than a GB or something like that??) TODO: would be nice to cancel stream NOTE: for v2 we could have two query params i.e. find which could take in a relative path and or file name and        the other could be compress i.e. streaming a gzip vs the raw bytes..        the caveat here would be mack would need to decompress em.
     * /os/filesystem/file/read/streamed [WS]
     */
    async osFilesystemFileReadStreamed(requestParameters: OsFilesystemFileReadStreamedRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<OSFileStreamingRead> {
        const response = await this.osFilesystemFileReadStreamedRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * This will determine in a given path is a file/a directory or invalid.
     * /os/filesystem/path/verify [POST]
     */
    async osFilesystemPathVerifyRaw(requestParameters: OsFilesystemPathVerifyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<VerifiedOSFilesystemPath>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Application-ID"] = await this.configuration.apiKey("X-Application-ID"); // application authentication
        }

        const response = await this.request({
            path: `/os/filesystem/path/verify`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['body'] as any,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => VerifiedOSFilesystemPathFromJSON(jsonValue));
    }

    /**
     * This will determine in a given path is a file/a directory or invalid.
     * /os/filesystem/path/verify [POST]
     */
    async osFilesystemPathVerify(requestParameters: OsFilesystemPathVerifyRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<VerifiedOSFilesystemPath> {
        const response = await this.osFilesystemPathVerifyRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * This will trigger a filer picker and return the string paths of the files that were selected.
     * /os/filesystem/files/pick [POST]
     */
    async osFilesystemPickFilesRaw(requestParameters: OsFilesystemPickFilesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<string>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Application-ID"] = await this.configuration.apiKey("X-Application-ID"); // application authentication
        }

        const response = await this.request({
            path: `/os/filesystem/files/pick`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: FilePickerInputToJSON(requestParameters['filePickerInput']),
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * This will trigger a filer picker and return the string paths of the files that were selected.
     * /os/filesystem/files/pick [POST]
     */
    async osFilesystemPickFiles(requestParameters: OsFilesystemPickFilesRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<string>> {
        const response = await this.osFilesystemPickFilesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * This will trigger a folder picker and return the string paths of the folders that were selected.
     * /os/filesystem/folders/pick [POST]
     */
    async osFilesystemPickFoldersRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<string>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Application-ID"] = await this.configuration.apiKey("X-Application-ID"); // application authentication
        }

        const response = await this.request({
            path: `/os/filesystem/folders/pick`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * This will trigger a folder picker and return the string paths of the folders that were selected.
     * /os/filesystem/folders/pick [POST]
     */
    async osFilesystemPickFolders(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<string>> {
        const response = await this.osFilesystemPickFoldersRaw(initOverrides);
        return await response.value();
    }

    /**
     * This will optimize memory across PiecesOS.(TODO in the future might want to accept a body, so this will be a POST)
     * /os/memory/optimize [POST]
     */
    async osMemoryOptimizeRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Application-ID"] = await this.configuration.apiKey("X-Application-ID"); // application authentication
        }

        const response = await this.request({
            path: `/os/memory/optimize`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * This will optimize memory across PiecesOS.(TODO in the future might want to accept a body, so this will be a POST)
     * /os/memory/optimize [POST]
     */
    async osMemoryOptimize(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.osMemoryOptimizeRaw(initOverrides);
    }

    /**
     * This will return metadata (total materials) in your pieces drive.
     * /os/metadata [GET]
     */
    async osMetadataRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<OSServerMetadata>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Application-ID"] = await this.configuration.apiKey("X-Application-ID"); // application authentication
        }

        const response = await this.request({
            path: `/os/metadata`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => OSServerMetadataFromJSON(jsonValue));
    }

    /**
     * This will return metadata (total materials) in your pieces drive.
     * /os/metadata [GET]
     */
    async osMetadata(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<OSServerMetadata> {
        const response = await this.osMetadataRaw(initOverrides);
        return await response.value();
    }

    /**
     * This endpoint will prepare our nano models  note: for now we will support task specific model groups.
     * /os/nano_models/prepare [POST]
     */
    async osNanoModelsPrepareRaw(requestParameters: OsNanoModelsPrepareRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Application-ID"] = await this.configuration.apiKey("X-Application-ID"); // application authentication
        }

        const response = await this.request({
            path: `/os/nano_models/prepare`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: NanoModelsPreparationInputToJSON(requestParameters['nanoModelsPreparationInput']),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * This endpoint will prepare our nano models  note: for now we will support task specific model groups.
     * /os/nano_models/prepare [POST]
     */
    async osNanoModelsPrepare(requestParameters: OsNanoModelsPrepareRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.osNanoModelsPrepareRaw(requestParameters, initOverrides);
    }

    /**
     * This will only work on Macos and Windows.  And will get the permissions of the user\'s local machine w/ regard to anything needed to effectively run PiecesOS.  Note: this will let us know if we need to tell them to take action to enable any given permissions
     * /os/permissions [GET]
     */
    async osPermissionsRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<OSPermissions>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Application-ID"] = await this.configuration.apiKey("X-Application-ID"); // application authentication
        }

        const response = await this.request({
            path: `/os/permissions`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => OSPermissionsFromJSON(jsonValue));
    }

    /**
     * This will only work on Macos and Windows.  And will get the permissions of the user\'s local machine w/ regard to anything needed to effectively run PiecesOS.  Note: this will let us know if we need to tell them to take action to enable any given permissions
     * /os/permissions [GET]
     */
    async osPermissions(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<OSPermissions> {
        const response = await this.osPermissionsRaw(initOverrides);
        return await response.value();
    }

    /**
     * This will only work on Macos and Windows.  This will request permissions for the given inputs
     * /os/permissions/request [POST]
     */
    async osPermissionsRequestRaw(requestParameters: OsPermissionsRequestRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<OSPermissions>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Application-ID"] = await this.configuration.apiKey("X-Application-ID"); // application authentication
        }

        const response = await this.request({
            path: `/os/permissions/request`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: OSPermissionsToJSON(requestParameters['oSPermissions']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => OSPermissionsFromJSON(jsonValue));
    }

    /**
     * This will only work on Macos and Windows.  This will request permissions for the given inputs
     * /os/permissions/request [POST]
     */
    async osPermissionsRequest(requestParameters: OsPermissionsRequestRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<OSPermissions> {
        const response = await this.osPermissionsRequestRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * This will restart PiecesOS, if successfull with return a 204. This is a LOCALOS Only Endpoint.
     * Your GET endpoint
     */
    async osRestartRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Application-ID"] = await this.configuration.apiKey("X-Application-ID"); // application authentication
        }

        const response = await this.request({
            path: `/os/restart`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * This will restart PiecesOS, if successfull with return a 204. This is a LOCALOS Only Endpoint.
     * Your GET endpoint
     */
    async osRestart(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.osRestartRaw(initOverrides);
    }

    /**
     * This is a snapshot of the piecesOS settings
     * /os/settings [GET]
     */
    async osSettingsSnapshotRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<OSServerSettings>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Application-ID"] = await this.configuration.apiKey("X-Application-ID"); // application authentication
        }

        const response = await this.request({
            path: `/os/settings`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => OSServerSettingsFromJSON(jsonValue));
    }

    /**
     * This is a snapshot of the piecesOS settings
     * /os/settings [GET]
     */
    async osSettingsSnapshot(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<OSServerSettings> {
        const response = await this.osSettingsSnapshotRaw(initOverrides);
        return await response.value();
    }

    /**
     * This is a websocket that will emit a change on the update of the OSSettings.
     * /os/settings/stream [WS]
     */
    async osSettingsStreamRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<OSServerSettings>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Application-ID"] = await this.configuration.apiKey("X-Application-ID"); // application authentication
        }

        const response = await this.request({
            path: `/os/settings/stream`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => OSServerSettingsFromJSON(jsonValue));
    }

    /**
     * This is a websocket that will emit a change on the update of the OSSettings.
     * /os/settings/stream [WS]
     */
    async osSettingsStream(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<OSServerSettings> {
        const response = await this.osSettingsStreamRaw(initOverrides);
        return await response.value();
    }

    /**
     * This will ensure that we update the os settings.  This will emit a change via the setting stream as well.
     * /os/settings/update [POST]
     */
    async osSettingsUpdateRaw(requestParameters: OsSettingsUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<OSServerSettings>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Application-ID"] = await this.configuration.apiKey("X-Application-ID"); // application authentication
        }

        const response = await this.request({
            path: `/os/settings/update`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: OSServerSettingsToJSON(requestParameters['oSServerSettings']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => OSServerSettingsFromJSON(jsonValue));
    }

    /**
     * This will ensure that we update the os settings.  This will emit a change via the setting stream as well.
     * /os/settings/update [POST]
     */
    async osSettingsUpdate(requestParameters: OsSettingsUpdateRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<OSServerSettings> {
        const response = await this.osSettingsUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * This will force quit PiecesOS
     * /os/terminate [POST]
     */
    async osTerminateRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Application-ID"] = await this.configuration.apiKey("X-Application-ID"); // application authentication
        }

        const response = await this.request({
            path: `/os/terminate`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * This will force quit PiecesOS
     * /os/terminate [POST]
     */
    async osTerminate(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.osTerminateRaw(initOverrides);
    }

    /**
     * This is a helper endpoint that will check the status of an update for PiecesOS. IE if there is an update downloading, if there is one available, but the downloading has not started... etc
     * /os/update/check [POST]
     */
    async osUpdateCheckRaw(requestParameters: OsUpdateCheckRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<OSServerUpdateStatus>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Application-ID"] = await this.configuration.apiKey("X-Application-ID"); // application authentication
        }

        const response = await this.request({
            path: `/os/update/check`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: UncheckedOSServerUpdateToJSON(requestParameters['uncheckedOSServerUpdate']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => OSServerUpdateStatusFromJSON(jsonValue));
    }

    /**
     * This is a helper endpoint that will check the status of an update for PiecesOS. IE if there is an update downloading, if there is one available, but the downloading has not started... etc
     * /os/update/check [POST]
     */
    async osUpdateCheck(requestParameters: OsUpdateCheckRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<OSServerUpdateStatus> {
        const response = await this.osUpdateCheckRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * This will first kick off the check.  Then will stream the progress.  **TODO lets think about if we want to have a closing NOTE: it is reccommended to use the stream instead of pulling(via the normal check endpoint).
     * /os/update/check/stream [WS]
     */
    async osUpdateCheckStreamRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<OSServerUpdateStatus>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Application-ID"] = await this.configuration.apiKey("X-Application-ID"); // application authentication
        }

        const response = await this.request({
            path: `/os/update/check/stream`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => OSServerUpdateStatusFromJSON(jsonValue));
    }

    /**
     * This will first kick off the check.  Then will stream the progress.  **TODO lets think about if we want to have a closing NOTE: it is reccommended to use the stream instead of pulling(via the normal check endpoint).
     * /os/update/check/stream [WS]
     */
    async osUpdateCheckStream(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<OSServerUpdateStatus> {
        const response = await this.osUpdateCheckStreamRaw(initOverrides);
        return await response.value();
    }

    /**
     * A trigger that launches a Sign into OS Server
     * 
     */
    async signIntoOSRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UserProfile>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Application-ID"] = await this.configuration.apiKey("X-Application-ID"); // application authentication
        }

        const response = await this.request({
            path: `/os/sign_in`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UserProfileFromJSON(jsonValue));
    }

    /**
     * A trigger that launches a Sign into OS Server
     * 
     */
    async signIntoOS(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UserProfile> {
        const response = await this.signIntoOSRaw(initOverrides);
        return await response.value();
    }

    /**
     * A trigger that signs out a user from the OS
     * /os/sign_out [POST]
     */
    async signOutOfOSRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Users>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-Application-ID"] = await this.configuration.apiKey("X-Application-ID"); // application authentication
        }

        const response = await this.request({
            path: `/os/sign_out`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UsersFromJSON(jsonValue));
    }

    /**
     * A trigger that signs out a user from the OS
     * /os/sign_out [POST]
     */
    async signOutOfOS(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Users> {
        const response = await this.signOutOfOSRaw(initOverrides);
        return await response.value();
    }

}
