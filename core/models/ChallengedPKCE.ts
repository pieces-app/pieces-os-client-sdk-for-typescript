/* tslint:disable */
/* eslint-disable */
/**
 * Pieces Isomorphic OpenAPI
 * Endpoints for Assets, Formats, Users, Asset, Format, User.
 *
 * The version of the OpenAPI document: 1.0
 * Contact: tsavo@pieces.app
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { mapValues } from '../runtime';
import type { EmbeddedModelSchema } from './EmbeddedModelSchema';
import {
    EmbeddedModelSchemaFromJSON,
    EmbeddedModelSchemaFromJSONTyped,
    EmbeddedModelSchemaToJSON,
    EmbeddedModelSchemaToJSONTyped,
} from './EmbeddedModelSchema';

/**
 * A model that Generates A PKCE Challenge Object with the needed requirements.
 * @export
 * @interface ChallengedPKCE
 */
export interface ChallengedPKCE {
    /**
     * 
     * @type {EmbeddedModelSchema}
     * @memberof ChallengedPKCE
     */
    schema?: EmbeddedModelSchema;
    /**
     * An opaque value the clients adds to the initial request that Auth0 includes when redirecting the back to the client. This value must be used by the client to prevent CSRF attacks.
     * @type {string}
     * @memberof ChallengedPKCE
     */
    state: string;
    /**
     * A local key that is held as the comparator to state, thus they should be the same.
     * @type {string}
     * @memberof ChallengedPKCE
     */
    nonce: string;
    /**
     * Generated challenge from the code_verifier.
     * @type {string}
     * @memberof ChallengedPKCE
     */
    challenge: string;
    /**
     * Method used to generate the challenge. The PKCE spec defines two methods, S256 and plain, however, Auth0 supports only S256 since the latter is discouraged.
     * @type {string}
     * @memberof ChallengedPKCE
     */
    method: ChallengedPKCEMethodEnum;
    /**
     * Cryptographically random key that was used to generate the code_challenge passed to /authorize.
     * @type {string}
     * @memberof ChallengedPKCE
     */
    verifier: string;
}
/**
 * @export
 */
export const ChallengedPKCEMethodEnum = {
    Unknown: 'UNKNOWN',
    S256: 'S256'
} as const;
export type ChallengedPKCEMethodEnum = typeof ChallengedPKCEMethodEnum[keyof typeof ChallengedPKCEMethodEnum];

    export function instanceOfChallengedPKCEMethodEnum(value: any): boolean {
        for (const key in ChallengedPKCEMethodEnum) {
            if (Object.prototype.hasOwnProperty.call(ChallengedPKCEMethodEnum, key)) {
                if (ChallengedPKCEMethodEnum[key as keyof typeof ChallengedPKCEMethodEnum] === value) {
                    return true;
                }
            }
        }
        return false;
    }

    export function ChallengedPKCEMethodEnumFromJSON(json: any): ChallengedPKCEMethodEnum {
        return ChallengedPKCEMethodEnumFromJSONTyped(json, false);
    }

    export function ChallengedPKCEMethodEnumFromJSONTyped(json: any, ignoreDiscriminator: boolean): ChallengedPKCEMethodEnum {
        if (json === null || json === undefined) {
            // Return x-enum-default
            return 'UNKNOWN' as ChallengedPKCEMethodEnum;
        }

        if (instanceOfChallengedPKCEMethodEnum(json)) {
            return json as ChallengedPKCEMethodEnum;
        }
        else {
            // Return x-enum-default
            return 'UNKNOWN' as ChallengedPKCEMethodEnum;
        }
    }

    export function ChallengedPKCEMethodEnumToJSON(value?: ChallengedPKCEMethodEnum | null): any {
        if (value === null || value === undefined) {
            // Return x-enum-default
            return 'UNKNOWN' as ChallengedPKCEMethodEnum;
        }

        // This must be checked when arguments are passed as 'any'
            if (instanceOfChallengedPKCEMethodEnum(value)) {
            return value as ChallengedPKCEMethodEnum;
        }
        else {
            // Return x-enum-default
            return 'UNKNOWN' as ChallengedPKCEMethodEnum;
        }
    }

    export function ChallengedPKCEMethodEnumToJSONTyped(value: any, ignoreDiscriminator: boolean): ChallengedPKCEMethodEnum {
        if (value === null || value === undefined) {
            // Return x-enum-default
            return 'UNKNOWN' as ChallengedPKCEMethodEnum;
        }
        if (instanceOfChallengedPKCEMethodEnum(value)) {
            return value as ChallengedPKCEMethodEnum;
        }
        else {
            // Return x-enum-default
            return 'UNKNOWN' as ChallengedPKCEMethodEnum;
        }
    }



/**
 * Check if a given object implements the ChallengedPKCE interface.
 */
export function instanceOfChallengedPKCE(value: object): value is ChallengedPKCE {
    if (!('state' in value) || value['state'] === undefined) return false;
    if (!('nonce' in value) || value['nonce'] === undefined) return false;
    if (!('challenge' in value) || value['challenge'] === undefined) return false;
    if (!('method' in value) || value['method'] === undefined) return false;
    if (!('verifier' in value) || value['verifier'] === undefined) return false;
    return true;
}

export function ChallengedPKCEFromJSON(json: any): ChallengedPKCE {
    return ChallengedPKCEFromJSONTyped(json, false);
}

export function ChallengedPKCEFromJSONTyped(json: any, ignoreDiscriminator: boolean): ChallengedPKCE {
    if (json == null) {
        return json;
    }
    return {
        
        'schema': json['schema'] == null ? undefined : EmbeddedModelSchemaFromJSON(json['schema']),
        'state': json['state'],
        'nonce': json['nonce'],
        'challenge': json['challenge'],
        'method': ChallengedPKCEMethodEnumFromJSON(json['method']),
        'verifier': json['verifier'],
    };
}

export function ChallengedPKCEToJSON(json: any): ChallengedPKCE {
    return ChallengedPKCEToJSONTyped(json, false);
}

export function ChallengedPKCEToJSONTyped(value?: ChallengedPKCE | null, ignoreDiscriminator: boolean = false): any {
    if (value == null) {
        return value;
    }

    return {
        
        'schema': EmbeddedModelSchemaToJSON(value['schema']),
        'state': value['state'],
        'nonce': value['nonce'],
        'challenge': value['challenge'],
        'method': ChallengedPKCEMethodEnumToJSON(value['method']),
        'verifier': value['verifier'],
    };
}

